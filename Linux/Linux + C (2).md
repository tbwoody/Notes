**1．进程和线程的差别。**     
线程是指进程内的一个执行单元,也是进程内的可调度实体.            
与进程的区别:              
(1)调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。                       
(2)并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行。               
(3)拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。               
(4)系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。        

**2．Heap与stack的差别。**      
Heap是堆，stack是栈。    
Stack的空间由操作系统自动分配/释放，Heap上的空间手动分配/释放。           
Stack空间有限，Heap是很大的自由存储区。              
C中的malloc函数分配的内存空间即在堆上,C++中对应的是new操作符。              
程序在编译期对变量和函数分配内存都在栈上进行,且程序运行过程中函数调用时参数的传递也在栈上进行。      

**3. 网络编程中设计并发服务器，使用多进程 与 多线程 ，请问有什么区别？**      
1. 进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。             
2. 线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。
两者都可以提高程序的并发度，提高程序运行效率和响应时间。            
线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。   

**4.引用与指针有什么区别？**                  
1) 引用必须被初始化，指针不必。             
2) 引用初始化以后不能被改变，指针可以改变所指的对象。                   
3) 不存在指向空值的引用，但是存在指向空值的指针。 

**5. 一语句实现x是否为2的若干次幂的判断**            
```
int i = 512;
cout << boolalpha << ((i & (i - 1)) ? false : true) << endl;
```

**6. 以下代码中的两个sizeof用法有问题吗？**       
```
void UpperCase( char str[] ) // 将 str 中的小写字母转换成大写字母
{
for( size_t i=0; i<sizeof(str)/sizeof(str[0]); ++i )
if( 'a'<=str[i] && str[i]<='z' )
str[i] -= ('a'-'A' );
}
char str[] = "aBcDe";
cout << "str字符长度为: " << sizeof(str)/sizeof(str[0]) << endl;
UpperCase( str );
cout << str << endl;
```

答：函数内的sizeof有问题。根据语法，sizeof如用于数组，只能测出静态数组的大小，无法检测动态分配的或外部数组大小。函数外的str是一个静态定义的数组，因此其大小为6，函数内的str实际只是一个指向字符串的指针，没有任何额外的与数组相关的信息，因此sizeof作用于上只将其当指针看，一个指针为4个字节，因此返回4。             


**7. 交换两个变量的值，不使用第三个变量。即a=3,b=5,交换之后a=5,b=3;**    
有两种解法, 一种用算术算法, 一种用^(异或)      
a = a + b;           
b = a - b;         
a = a - b;         
or            
a = a^b;// 只能对int,char..          
b = a^b;         
a = a^b;         
or        
a ^= b ^= a;       


**8. c和c++中的struct有什么不同？**           
c和c++中struct的主要区别是c中的struct不可以含有成员函数，而c++中的struct可以。c++中struct和class的主要区别在于默认的存取权限不同，struct默认为public，而class默认为private.      

**9. 列举几种进程的同步机制，并比较其优缺点。**          
原子操作         
信号量机制            
自旋锁          
管程，会合，分布式系统          

**10. 进程之间通信的途径**       
共享存储系统       
消息传递系统       
管道：以文件系统为基础         

**11. 进程死锁的原因**      
资源竞争及进程推进顺序非法

**12. 死锁的4个必要条件**         
互斥、请求保持、不可剥夺、环路           

**13. 死锁的处理**             
鸵鸟策略、预防策略、避免策略、检测与解除死锁        

**14. 操作系统中进程调度策略有哪几种？**      
FCFS(先来先服务)，优先级，时间片轮转，多级反馈          

**15. ISO的七层模型是什么？tcp/udp是属于哪一层？tcp/udp有何优缺点？**             
应用层/Application Layer          
表示层/Presentation Layer             
会话层/Session Layer          
运输层/Transport Layer             
网络层/Network Layer                  
物理链路层/Data-Link Layer              
物理层/Physical Layer       

tcp /udp属于运输层            
TCP 服务提供了数据流传输、可靠性、有效流控制、全双工操作和多路复用技术等。            
与 TCP 不同， UDP 并不提供对 IP 协议的可靠机制、流控制以及错误恢复功能等。由于 UDP 比较简单， UDP 头包含很少的字节，比 TCP 负载消耗少。          
tcp: 提供稳定的传输服务，有流量控制，缺点是包头大，冗余性不好.         
udp: 不提供稳定的服务，包头小，开销小.         



**16. 分析下面的程序：**    
```
void GetMemory(char **p,int num)
{
    *p=(char *)malloc(num);

}

int main()
{
    char *str=NULL;

    GetMemory(&str,100);

    strcpy(str,"hello");

    free(str);

    if(str!=NULL)
    {
        strcpy(str,"world");
    }

    printf("\n str is %s",str);
    getchar();
}
```
问输出结果是什么？希望大家能说说原因，先谢谢了       
输出str is world。           
free 只是释放的str指向的内存空间,它本身的值还是存在的.            
所以free之后，有一个好的习惯就是将str=NULL.            
此时str指向空间的内存已被回收,如果输出语句之前还存在分配空间的操作的话,这段存储空间是可能被重新分配给其他变量的,        
尽管这段程序确实是存在大大的问题（上面各位已经说得很清楚了），但是通常会打印出world来。            
这是因为，进程中的内存管理一般不是由操作系统完成的，而是由库函数自己完成的。         
当你malloc一块内存的时候，管理库向操作系统申请一块空间（可能会比你申请的大一些），然后在这块空间中记录一些管理信息（一般是在你申请的内存前面一点），并将可用内存的地址返回。但是释放内存的时候，管理库通常都不会将内存还给操作系统，因此你是可以继续访问这块地址的，只不过。。。。。。。。楼上都说过了，最好别这么干。        
